// --- Types ---

/** Represents a JSON Patch (RFC 6902) */
type JsonPatch = Array<{ op: string; path: string; value?: any; from?: string }>;

/** Represents a pending mutation */
interface PendingMutation {
  clientMutationId: string;
  optimisticPatch: JsonPatch;
  inversePatch: JsonPatch;
  expectedServerSeq: number; // Sequence number *after* this mutation is applied on the server
}

/** Callbacks provided by the state layer */
interface SyncCoordinatorCallbacks {
  /** Apply a patch to the local state */
  applyPatch: (patch: JsonPatch) => Promise<void>; // Async to allow state updates
  /** Apply an inverse patch to rollback a mutation */
  rollbackPatch: (patch: JsonPatch) => Promise<void>; // Async to allow state updates
  /** Request a full state resynchronization from the server */
  requestResync: () => Promise<void>;
  /** (Optional) Notify of potential conflicts needing resolution */
  notifyConflict?: (details: { clientMutationId: string; serverSeq: number; serverPatch: JsonPatch }) => void;
}

// --- Interface ---

interface IOptimisticSyncCoordinator {
  /** The last sequence number confirmed by the server */
  readonly confirmedServerSeq: number;

  /** The queue of mutations applied locally but not yet confirmed by the server */
  readonly pendingMutations: ReadonlyArray<PendingMutation>;

  /**
   * Registers a mutation initiated by the client.
   * Applies the optimistic patch locally via callback.
   * Adds the mutation to the pending queue.
   * @param clientMutationId A unique ID generated by the client for this mutation.
   * @param optimisticPatch The JSON Patch representing the change applied optimistically.
   * @param inversePatch The JSON Patch to revert the optimisticPatch if rejected.
   * @returns The expected server sequence number after this mutation is confirmed.
   */
  registerPendingMutation(
    clientMutationId: string,
    optimisticPatch: JsonPatch,
    inversePatch: JsonPatch
  ): Promise<number>;

  /**
   * Processes confirmation of a pending mutation from the server.
   * Removes the mutation from the pending queue.
   * Updates the confirmed server sequence number.
   * @param clientMutationId The ID of the confirmed mutation.
   * @param serverSeq The sequence number assigned by the server upon confirming the mutation.
   */
  confirmMutation(clientMutationId: string, serverSeq: number): Promise<void>;

  /**
   * Processes rejection of a pending mutation from the server.
   * Triggers a rollback of the optimistic patch via callback.
   * Removes the mutation from the pending queue.
   * May update the confirmed server sequence number based on server information.
   * @param clientMutationId The ID of the rejected mutation.
   * @param serverSeq The sequence number provided by the server alongside the rejection.
   */
  rejectMutation(clientMutationId: string, serverSeq: number): Promise<void>;

  /**
   * Processes a state delta received from the server.
   * Checks sequence numbers for consistency.
   * Applies the server patch via callback if consistent.
   * Handles sequence gaps (requesting resync).
   * **Placeholder:** Detects and potentially handles conflicts with pending mutations.
   * @param serverSeq The sequence number of this delta from the server.
   * @param serverPatch The JSON Patch representing the state change from the server.
   */
  processServerDelta(serverSeq: number, serverPatch: JsonPatch): Promise<void>;

  /**
   * Retrieves all patches currently pending confirmation.
   * Useful for resending mutations if connection is lost/re-established.
   */
  getPendingPatches(): ReadonlyArray<PendingMutation>;

  /**
   * Resets the coordinator's state, typically after a full resync.
   * @param initialServerSeq The authoritative sequence number from the server after resync.
   */
  resetState(initialServerSeq: number): void;
}

// --- Core Logic Outline (Conceptual) ---

class OptimisticSyncCoordinator implements IOptimisticSyncCoordinator {
  private _confirmedServerSeq = 0;
  private _pendingMutations: PendingMutation[] = [];
  private _nextClientSeq = 0; // Internal counter to derive expectedServerSeq
  private callbacks: SyncCoordinatorCallbacks;

  constructor(callbacks: SyncCoordinatorCallbacks, initialServerSeq = 0) {
    this.callbacks = callbacks;
    this._confirmedServerSeq = initialServerSeq;
    this._nextClientSeq = initialServerSeq + 1; // Start expecting next seq
  }

  get confirmedServerSeq(): number {
    return this._confirmedServerSeq;
  }

  get pendingMutations(): ReadonlyArray<PendingMutation> {
    return this._pendingMutations;
  }

  async registerPendingMutation(
    clientMutationId: string,
    optimisticPatch: JsonPatch,
    inversePatch: JsonPatch
  ): Promise<number> {
    const expectedServerSeq = this._nextClientSeq++;
    const mutation: PendingMutation = {
      clientMutationId,
      optimisticPatch,
      inversePatch,
      expectedServerSeq,
    };

    this._pendingMutations.push(mutation);
    await this.callbacks.applyPatch(optimisticPatch); // Apply optimistically
    // NOTE: The actual sending of the mutation to the server happens outside the coordinator
    return expectedServerSeq;
  }

  async confirmMutation(clientMutationId: string, serverSeq: number): Promise<void> {
     const index = this._pendingMutations.findIndex(m => m.clientMutationId === clientMutationId);
     if (index === -1) {
        console.warn(`Confirmation for unknown or already processed mutation: ${clientMutationId}`);
        // Decide if we need to update confirmedServerSeq even if mutation not found locally
        // This might happen if state was reset or connection lost/restored
        this._confirmedServerSeq = Math.max(this._confirmedServerSeq, serverSeq);
        this._nextClientSeq = Math.max(this._nextClientSeq, this._confirmedServerSeq + 1);
        return;
     }

     const confirmedMutation = this._pendingMutations[index];

     // Consistency check: Did server confirm with the expected sequence?
     if (confirmedMutation.expectedServerSeq !== serverSeq) {
         console.warn(`Server confirmed mutation ${clientMutationId} with unexpected sequence ${serverSeq} (expected ${confirmedMutation.expectedServerSeq}). Potential divergence.`);
         // This indicates a potential issue, might need resync or more complex handling.
         // For now, we trust the server's sequence number.
     }

     // Remove the confirmed mutation and any preceding it (assuming server processes sequentially)
     this._pendingMutations = this._pendingMutations.filter(m => m.expectedServerSeq > serverSeq);

     // Update confirmed sequence
     this._confirmedServerSeq = Math.max(this._confirmedServerSeq, serverSeq);
     // Ensure next client sequence is ahead
     this._nextClientSeq = Math.max(this._nextClientSeq, this._confirmedServerSeq + 1);

     // Potential: Re-evaluate pending mutations based on the new confirmed state (advanced conflict resolution)
  }


  async rejectMutation(clientMutationId: string, serverSeq: number): Promise<void> {
    const index = this._pendingMutations.findIndex(m => m.clientMutationId === clientMutationId);
    if (index === -1) {
      console.warn(`Rejection for unknown or already processed mutation: ${clientMutationId}`);
       // Update confirmed sequence based on server info, even if mutation is gone
       this._confirmedServerSeq = Math.max(this._confirmedServerSeq, serverSeq);
       this._nextClientSeq = Math.max(this._nextClientSeq, this._confirmedServerSeq + 1);
      return;
    }

    const rejectedMutation = this._pendingMutations[index];

    // --- Rollback Logic ---
    // 1. Find all mutations including and after the rejected one.
    const mutationsToRollback = this._pendingMutations.slice(index);
    // 2. Apply inverse patches in reverse order.
    for (let i = mutationsToRollback.length - 1; i >= 0; i--) {
      await this.callbacks.rollbackPatch(mutationsToRollback[i].inversePatch);
    }
    // 3. Remove the rejected mutation from the internal queue.
    //    (Important: Do this *after* rollback to ensure correct state)
    this._pendingMutations.splice(index, 1);
    // 4. Update confirmed sequence based on server info.
    this._confirmedServerSeq = Math.max(this._confirmedServerSeq, serverSeq);
    // 5. Re-apply the mutations that came *after* the rejected one (rebase).
    //    This requires careful state management and potentially patch transformation if server deltas arrived concurrently.
    //    For now, we assume a simple re-application might work, but flag this as complex.
    const mutationsToReapply = mutationsToRollback.slice(1); // Exclude the rejected one
    for (const mutation of mutationsToReapply) {
        // TODO: This is overly simplistic. Re-application might fail or need transformation
        // based on the state *after* rollback and potential intervening server deltas.
        // This is a core part of conflict resolution.
        await this.callbacks.applyPatch(mutation.optimisticPatch);
    }

    // Ensure next client sequence is ahead
    this._nextClientSeq = Math.max(this._nextClientSeq, this._confirmedServerSeq + 1 + this._pendingMutations.length); // Account for remaining pending

    console.log(`Rolled back and potentially re-applied mutations after rejection of ${clientMutationId}`);
  }

  async processServerDelta(serverSeq: number, serverPatch: JsonPatch): Promise<void> {
    if (serverSeq <= this._confirmedServerSeq) {
      console.log(`Ignoring stale server delta with seq ${serverSeq} (confirmed is ${this._confirmedServerSeq})`);
      return; // Ignore stale delta
    }

    if (serverSeq > this._confirmedServerSeq + 1) {
      console.warn(`Detected sequence gap. Expected ${this._confirmedServerSeq + 1}, got ${serverSeq}. Requesting resync.`);
      await this.callbacks.requestResync();
      return;
    }

    // --- Conflict Detection / Resolution Placeholder ---
    // Check if this delta conflicts with any pending mutations.
    // A conflict occurs if a server delta arrives with a sequence number *less than or equal to*
    // the expectedServerSeq of a pending mutation. This means the server state changed
    // *before* our optimistic mutation was processed/confirmed there.
    const conflictingMutations = this._pendingMutations.filter(m => serverSeq <= m.expectedServerSeq);

    if (conflictingMutations.length > 0) {
        console.warn(`Server delta seq ${serverSeq} potentially conflicts with pending mutations:`, conflictingMutations.map(m => m.clientMutationId));
        // **CRITICAL:** This is where complex conflict resolution logic is needed.
        // 1. Rollback optimistic patches of conflicting mutations (and subsequent ones).
        // 2. Apply the serverPatch.
        // 3. Transform/rebase the optimistic patches of the conflicting mutations against the serverPatch.
        // 4. Re-apply the transformed patches.
        // This often requires Operational Transformation (OT) or similar algorithms,
        // or relying on the server to resolve and send definitive state.
        // For now, we might just notify or request resync as a simpler strategy.
        if (this.callbacks.notifyConflict) {
            this.callbacks.notifyConflict({ clientMutationId: 'multiple', serverSeq, serverPatch }); // Simplified notification
        } else {
            console.error("Conflict detected but no resolution strategy implemented. Requesting resync.");
            await this.callbacks.requestResync();
            return; // Stop processing this delta if resync requested
        }
        // Assuming notification allows external handling, we still apply the server patch for now
    }

    // Apply the server patch
    await this.callbacks.applyPatch(serverPatch);
    this._confirmedServerSeq = serverSeq;

    // Ensure next client sequence is ahead
    this._nextClientSeq = Math.max(this._nextClientSeq, this._confirmedServerSeq + 1 + this._pendingMutations.length); // Account for pending

    console.log(`Applied server delta seq ${serverSeq}. Confirmed seq is now ${this._confirmedServerSeq}`);
  }

  getPendingPatches(): ReadonlyArray<PendingMutation> {
    return this._pendingMutations;
  }

  resetState(initialServerSeq: number): void {
      this._confirmedServerSeq = initialServerSeq;
      this._pendingMutations = [];
      this._nextClientSeq = initialServerSeq + 1;
      console.log(`Coordinator state reset to server seq ${initialServerSeq}`);
  }
}

import type { Atom, WritableAtom } from 'nanostores';

// Define a type for the key used in the registry
// Using string for simplicity, likely JSON.stringify({ path, input })
export type AtomKey = string;

// Define the structure of the stored atom entry if needed (e.g., for metadata)
// For now, just storing the atom itself
// EXPORT this type
export type AtomRegistryEntry = WritableAtom<any>; // Use a more specific type if possible

const atomRegistry = new Map<AtomKey, AtomRegistryEntry>();

/**
 * Generates a unique key for a query or subscription based on its path and input.
 * Simple JSON stringification. Consider more robust hashing for complex inputs.
 * @param path - The procedure path (e.g., 'posts.get')
 * @param input - The input arguments for the procedure
 * @returns A unique string key
 */
export function generateAtomKey(path: string | string[], input: unknown): AtomKey {
  try {
    // Normalize path if it's an array
    const normalizedPath = Array.isArray(path) ? path.join('.') : path;
    // Stringify input, handling potential circular references or non-serializable values
    // A more robust solution might involve stable stringification or hashing
    const stringifiedInput = input === undefined ? 'undefined' : JSON.stringify(input);
    return `${normalizedPath}::${stringifiedInput}`;
  } catch (error) {
    console.error('[zenQuery] Failed to generate atom key. Input might not be serializable:', { path, input, error });
    // Fallback key - might lead to collisions!
    const normalizedPath = Array.isArray(path) ? path.join('.') : path;
    return `${normalizedPath}::[non-serializable-input]-${Math.random()}`;
  }
}


/**
 * Registers a Nanostore atom with a unique key.
 * @param key - The unique key generated by generateAtomKey
 * @param atom - The Nanostore atom instance (should be writable)
 */
export function registerAtom(key: AtomKey, atom: AtomRegistryEntry): void {
  if (atomRegistry.has(key)) {
    // TODO: Decide on behavior for duplicate registration. Warn? Error? Replace?
    console.warn(`[zenQuery] Atom already registered for key: ${key}. Overwriting.`);
  }
  atomRegistry.set(key, atom);
  // console.log(`[zenQuery] Atom registered: ${key}`);
}

/**
 * Unregisters an atom using its key.
 * @param key - The unique key
 */
export function unregisterAtom(key: AtomKey): void {
  if (atomRegistry.has(key)) {
    atomRegistry.delete(key);
    // console.log(`[zenQuery] Atom unregistered: ${key}`);
  } else {
    // console.warn(`[zenQuery] Attempted to unregister non-existent atom key: ${key}`);
  }
}

/**
 * Retrieves an atom from the registry using its key.
 * @param key - The unique key
 * @returns The atom instance, or undefined if not found
 */
export function getAtom(key: AtomKey): AtomRegistryEntry | undefined {
  return atomRegistry.get(key);
}

/**
 * Clears the entire atom registry. Useful for testing or full resets.
 */
export function clearAtomRegistry(): void {
  atomRegistry.clear();
  console.log('[zenQuery] Atom registry cleared.');
}

// Optional: Add functions to get all keys or iterate over the registry if needed